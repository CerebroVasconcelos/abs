#!/bin/bash
#
# ABS Backup System
# Copyright (C) 2011 SitePoint Pty Ltd
#
# Contact details provided at http://www.sitepoint.com/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


## Variables
#

declare -r backupCfg="/usr/local/etc/abs.conf"
declare -r lockFile="/var/run/backups.pid"
declare -r scriptName="$(basename ${0})"
declare -r backupNameDefault="daily"
declare -i verbose=0
declare backupName


## Functions
#

function doSafetyChecks()
{
    # Check we're running as root.
    if [ "${UID}" -ne 0 ]
    then
        echo "Error: Must be run as root."
        exit 1
    fi

    # Check the config file exists.
    if [ ! -f "${backupCfg}" ]
    then
        echo "Error: Configuration file not found."
        exit 1
    fi

    # Set a default backup name if required.
    if [ -z "${backupName}" ]
    then
        backupName="${backupNameDefault}"
    fi

    # Ignore comments, condense whitespace, and then verify that the requested
    # backup has entries in the configuration file.
    sed -e 's/#.*$//;s/[[:space:]]\+/\ /g' "${backupCfg}" | \
        grep -q "[[:space:]]\+${backupName}[[:space:]]*$"
    if [ "${?}" -ne 0 ]
    then
        echo -n "Error: No entries for '${backupName}' in file "
        echo "'${backupCfg}'."
        exit 1
    fi
}

function setLockFile()
{
    declare cmdAtPID

    # If the lockfile exists
    if [ -f "${lockFile}" ]
    then
        # If the lockfile points to a process by the same name
        cmdAtPID="$(ps -p $(cat "${lockFile}") -o comm=)"
        echo "${cmdAtPID}" | grep -q "^${scriptName}$"
        if [ "${?}" -eq 0 ]
        then
            # Wait 10 minutes and try again.
            echo "Sleeping, waiting for the lock to free up."
            sleep 600
            setLockFile
        else
            # Old lock file. Overwrite it.
            echo ${$} > "${lockFile}"
        fi
    else
        echo ${$} > "${lockFile}"
    fi
}

function delLockFile()
{
    rm -f "${lockFile}"
}

function checkIsSource()
{
    declare -r variable="${1}"
    declare -r variableLine="${2}"
    declare hostName
    declare pathName

    hostName="$(echo ${variable} | cut -d ':' -f 1)"
    pathName="$(echo ${variable} | cut -d ':' -f 2)"

    checkIsHost ${hostName} ${variableLine}
    checkIsPath ${pathName} ${variableLine} 0
}

function checkIsPath()
{
    declare -r variable="${1}"
    declare -r variableLine="${2}"
    declare -ri checkPath="${3}"  # Check if it exists locally?

    echo "${variable}" | grep -q '^\/.*$' || \
        {
            echo -n "Error: '${variable}' is not an absolute "
            echo "path on line ${variableLine} of file '${backupCfg}'."
            exit 1
        }

    if [ "${checkPath}" -eq 1 -a ! -d "${variable}" ]
    then
        echo -n "Error: '${variable}' (referenced on line "
        echo "${variableLine} of file '${backupCfg}') does not exist!"
        exit 1
    fi
}

function checkIsInt()
{
    declare -r variable="${1}"
    declare -r variableName="${2}"
    declare -r variableLine="${3}"

    echo "${variable}" | grep -q '^[[:digit:]]*$' || \
        {
            echo -n "Error: '${variableName}' is not an integer on "
            echo "line ${variableLine} of file '${backupCfg}'."
            exit 1
        }
}

function checkIsAlnum()
{
    declare -r backup="${1}"
    declare -r backup_name="${2}"
    declare -r lineNum="${3}"

    echo "${backup}" | grep -q '^[[:alnum:]_-]*$' || \
        {
            echo -n "Error: '${backup_name}' is not an integer on "
            echo "line ${lineNum} of file '${backupCfg}'."
            exit 1
        }
}

function checkIsHost()
{
    declare -r hostName="${1}"
    declare -r variableLine="${2}"

    ping -c 1 ${hostName} >/dev/null
    if [ "${?}" -ne 0 ]
    then
        echo -n "Warning: Cannot ping host '${hostName}', "
        echo -n "referenced on line ${variableLine} of file "
        echo -e "'${backupCfg}'.\nWe may fail at running rsync later."
    fi
}

function rsyncCmd()
{
    function rsyncFailMsg()
    {
        {
            echo -n "Warning: Rsync from "
            echo -n "root@${rmtHostName}:${rmtPathName} "
            echo "failed."
        } >&2
    }

    declare -r rmtHostName="${1}"
    declare -r rmtPathName="${2}"
    declare -r local_backup_dir="${3}"
    declare -i rsyncFail=0
    declare -r rsyncExclude="--exclude=/dev/*
        --exclude=/home/*/.gvfs
        --exclude=/lost+found/*
        --exclude=/proc/*
        --exclude=/sys/*
        --exclude=/tmp/*
        --exclude=/srv/chroot/wheezy/dev/*
        --exclude=/srv/chroot/wheezy/proc/*
        --exclude=/srv/chroot/wheezy/sys/*
        --exclude=/srv/chroot/wheezy/tmp/*"
    declare cmdWrap=""

    # Used by the bash time command.
    TIMEFORMAT=$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'

    echo "${rmtHostName}:${rmtPathName} -> ${local_backup_dir}"

    if [ "${verbose}" -ne 0 ]
    then
        cmdWrap="time"
    fi

    # We use eval so the bash (semi-)builtin command takes precedence
    # when the time package/comamnd is installed.
    if [ -d "${local_backup_dir}.1" ]
    then
        eval ${cmdWrap} rsync -a -e ssh --delete \
            $([ "${rmtPathName}" = "/" ] && echo ${rsyncExclude}) \
            --link-dest=${local_backup_dir}.1 \
            root@${rmtHostName}:${rmtPathName} \
            "${local_backup_dir}.0" || rsyncFail=1
    else
        eval ${cmdWrap} rsync -a -e ssh --delete \
            $([ "${rmtPathName}" = "/" ] && echo ${rsyncExclude}) \
            root@${rmtHostName}:${rmtPathName} \
            "${local_backup_dir}.0" || rsyncFail=1
    fi

    [ "${rsyncFail}" -ne 0 ] && rsyncFailMsg

    # Formatting improvements
    [ "${verbose}" -ne 0 ] && echo -e '\n'
}

function syncFiles()
{
    declare -r source_path="${1}"
    declare -r local_path="${2}"
    declare -i keep="${3}"
    declare -r backup_name="${4}"
    declare -r rmtHostName="$(echo ${source_path} | cut -d ':' -f 1)"
    declare -r rmtPathName="$(echo ${source_path} | cut -d ':' -f 2)"
    declare snapshotHourNum
    declare snapshotMonthNum
    declare snapshotYearNum
    declare -i rsyncFail=0

    # Unlike the config file, we count from 0. Subtract 1.
    (( keep-- ))

    for snapshotHourNum in $(seq ${keep} -1 0)
    do
        if [ "${snapshotHourNum}" -eq "${keep}" ]
        then
            # Delete the oldest snapshot
            rm -rf "${local_path}/${backup_name}.${snapshotHourNum}"
        else
            # Increment the snapshot number of all other exiting snapshots.
            if [ -d "${local_path}/${backup_name}.${snapshotHourNum}" ]
            then
                mv ${local_path}/${backup_name}.${snapshotHourNum} \
                    ${local_path}/${backup_name}.$(( snapshotHourNum + 1 ))
            fi
        fi

        if [ "${snapshotHourNum}" -eq 0 ]
        then
            if [ "${backupNameDefault}" = "${backup_name}" ]
            then
                rsyncCmd "${rmtHostName}" "${rmtPathName}" \
                    "${local_path}/${backup_name}"
            else
                # Just grab the latest default backup, if available.
                if [ -d "${local_path}/${backupNameDefault}.0" ]
                then
                    cp -al "${local_path}/${backupNameDefault}.0" \
                        "${local_path}/${backup_name}.0"
                else
                    rsyncCmd "${rmtHostName}" "${rmtPathName}" \
                        "${local_path}/${backup_name}"
                fi
            fi
        fi
    done
}

function doBackup()
{
    declare source_path
    declare local_path
    declare keep
    declare backup_name
    declare -i lineNum=0
    declare variable
    declare -r oldIFS="${IFS}"

    IFS=$'\n'

    while read line
    do
        (( lineNum++ ))

        # Ignore comments.
        line="$(echo "${line}" | sed -e 's/#.*$//')"

        # Ignore empty lines (including lines with only whitespace).
        [ -z "$(echo "${line}" | sed -e 's/[[:space:]]*//g')" ] && continue

        source_path="$(echo "${line}" | cut -d ' ' -f 1)"
        local_path="$(echo "${line}" | cut -d ' ' -f 2)"
        keep="$(echo "${line}" | cut -d ' ' -f 3)"
        backup_name="$(echo "${line}" | cut -d ' ' -f 4)"

        if [ "${backupName}" = "${backup_name}" ]
        then
            # Check config file lines look valid.
            checkIsSource ${source_path} ${lineNum}
            checkIsPath ${local_path} ${lineNum} 1
            checkIsInt ${keep} keep ${lineNum}
            checkIsAlnum ${backup_name} backup_name ${lineNum}

            syncFiles ${source_path} ${local_path} ${keep} ${backup_name}
        fi

    # When reading in the file, reduce any whitespace to a single space.
    done < <(sed -e 's/[[:space:]]\+/\ /g' ${backupCfg})

    IFS="${oldIFS}"
}

function printUsage()
{
    echo "Usage: ${0} [OPTIONS] [BACKUP]"
    echo
    echo "where:"
    echo
    echo "OPTIONS:"
    echo "-h      print help"
    echo "-v      be verbose"
    echo
    echo "BACKUP:"
    echo "Can be anything specified in ${backupCfg}"
    echo "(defaults to 'daily')."
    echo
    echo "eg."
    echo "# ${0} -v daily"
}

function printArgError
{
    echo "Error: unknown option '${@}'."
}

function getOpts()
{
    declare option
    declare -i failure=0
    declare -i help=0

    while getopts ":vh" option
    do
        case ${option} in
            h )
                [ "${help}" -ne 1 ] && help=1
                ;;
            v )
                [ "${verbose}" -ne 1 ] && verbose=1
                ;;
            * )
                {
                    printArgError ${OPTARG}
                    failure=1
                } >&2
                ;;
        esac
    done
    shift $(($OPTIND - 1))

    backupName="${1}"
    shift

    if [ -n "${*}" ]
    then
        printArgError ${@}
        failure=1
    fi

    if [ "${failure}" -ne 0 ]
    then
        echo -e "Aborting.\n"
        printUsage
        exit "${failure}" 
    fi

    [ "${help}" -ne 0 ] && { printUsage ; exit 0 ; }
    [ "${verbose}" -ne 0 ] && echo -e "Verbose mode activated.\n"
}


## Begin execution
#

getOpts ${@}
doSafetyChecks
setLockFile
doBackup
delLockFile

# EOF
